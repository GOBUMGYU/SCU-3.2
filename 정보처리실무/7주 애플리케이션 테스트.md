# 애플리케이션 테스트

## 애플리케이션 테스트

### 애플리케이션 테스트의 분류

- 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차

테스트를 통하여 고객의 요구사항을 만족시키는지 확인(Validation)하고 기능이 정확히 수행되는지 검증(Verfication)함

**애플리케이션 테스트의 기본 원리**

**완벽한 테스트 불가능**

- 소프트웨어의 잠재적인 결함은 줄일 수 있지만, 소프트웨어 무결함 증명은 불가능함

**파레토 법칙(Pareto Principle)**

- 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙

**살충제 패러독스**

- 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상

**테스팅은 정황 의존적**

- 소프트웨어의 특징 테스트 환경, 테스터의 역량 등 정황에 따라 결과가 달라질 수 있음

**오류 부재의 궤변(Absence of Errors Fallacy)**

- 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 품질이 높은 것은 아님

**테스트와 위험은 반비례**

- 테스트를 많이 할 수록 발생할 위험을 줄일 수 있음

**테스트의 점진적 확대**

- 테스트는 작은 부분에서 시작하여 점점 확대하며 진행해야 함

**테스트의 별도 팀 수행**

- 테스트는 개발자와 관계 없는 별도의 팀에서 수행해야 함

### 애플리케이션 테스트의 분류

**프로그램 실행 여부에 따른 테스트 분류**

**정적 테스트**

- 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석
- 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용
- 워크스루(전문가 검토 회의), 인스펙션(품질 평가), 코드 검사 등의 방법을 사용

**동적 테스트**

- 프로그램을 실행하여 오류를 발견함
- 소프트웨어 개발의 모든 단계에서 테스트를 수행
- 블랙박스 테스트, 화이트박스 테스트 등의 방법을 사용

**테스트 기반에 따른 테스트 분류**

**명세 기반 테스트**

- 사용자의 요구사항에 대한 명세를 모두 테스트 케이스로 만들어 구현 여부를 확인하는 방법
- 예 ) 동등 분할, 경계 값 분석 등

**구조 기반 테스트**

- 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 방법
- 예 ) 구문 기반, 결정 기반, 조건 기반 등

**경험 기반 테스트**

- 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 방법
- 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 효과적
- 예 ) 에러 추정, 체크 리스트, 탐색적 테스팅

**관점에 따른 테스트 분류**

**검증(verification) 테스트**

- 개발자의 시각에서 생산 과정을 테스트함
- 제품이 명세서대로 완성되었는지를 테스트함

**확인(Validation) 테스트**

- 사용자의 시각에서 제품의 결과를 테스트함
- 사용자의 요구대로 제품이 완성되었고 정상적으로 동작하는지 테스트함

**목적에 따른 테스트 분류**

**회복 테스트**

- 시스템에 여러 결함을 주어 실패하도록 한 후 복구되는지를 확인함

**안전 테스트**

- 시스템 보호 도구가 침입으로부터 시스템을 보호할 수 있는지 확인함

**강도 테스트**

- 과도한 정보량이나 빈도 등을 부과하여 상황에서도 정상적으로 실행되는지를 확인함

**성능 테스트**

- 실시간 성능이나 전체적인 효율성을 진단, 응답 시간, 처리량 등을 확인

**구조 테스트**

- 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가함

**회귀 테스트**

- 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인함

**병행 테스트**

변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교함

### 테스트 기법에 따른 분류

**화이트 박스 테스트**

- 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법

모듈 안의 작동을 직접 관찰함

원시 코드의 모든 문장을 한 번 이상 실행하여 수행

**화이트 박스 테스트의 종류**

- **기초 경로 검사**
    - 대표적인 화이트박스 테스트 기법
    - 테스트 케이스 설계자가 절차적인 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
- **제어 구조 검사**
    - 조건 검사 - 모듈 내에 있는 논리적 조건을 테스트하는 케이스 설계 기법
    - 루프 검사 - 반복 구조를 테스트하는 케이스 설계 기법
    - 데이터 흐름 검사 - 변수의 정의와 변수 사용 위치를 테스트하는 케이스 설계 기법

**화이트 박스 테스트의 검증 기준**

- **문장 검증 기준**
    - 소스 코드의 모든 구문이 수행되었는지를 확인
- **분기 검증 기준**
    - 각 분기문이 수행되었는지를 확인
- **조건 검증 기준**
    - 조건문에 대해 조건이 True인 경우와 False인 경우를 각각 수행되었는지 확인
- **분기/조건 기준**
    - 조건과 분기에 대하여 수행 확인

**블랙 박스 테스트**

- 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트

기능 테스트라고 부름

사용자의 요구사항 명세를 기반으로 구현된 기능을 테스트하며, 소프트웨어 인터페이스를 통해 실시됨

**블랙 박스 테스트의 종류**

**동치 분할 검사**

- 동치 클래스 분해
- 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고 결과 출력을 확인
- 동등 분할 기법이라고 부르기도 함

**경계값 분석**

- 입력 시 조건의 중간값보다 경계값에서 오류가 발생할 확률이 높다는 점을 이용하여 경계값을 테스트 케이스로 선정하는 방법

**원인-효과 그래프 검사**

- 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 분석한 다음 효용성이 높은 케이스를 선정하는 방법

**오류 예측 검사**

- 과거의 경험이나 확인자의 감으로 테스트하는 기법

**비교 검사**

- 여러 버전의 프로그램을 동일한 테스트 자료를 제공하여 동일한 결과를 출력되는지 테스트

### 개발 단계에 따른 분류

**소프트웨어 개발의 단계**

- 요구사항 → 분석 → 설계 → 구현

**소프트웨어 테스트 단계**

- 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트

**단위 테스트**

- 모듈이나 컴포넌트에 초점을 맞춰 테스트 하는 것
- 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사ㅌ
- 사용자의 요구사항에 대해 테스트를 최우선으로 수행

**통합 테스트**

- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정을 테스트
- 모듈 간 또는 통합된 컴포넌트간의 상호 작용 오류를 검사

**시스템 테스트**

- 개발된 소프트웨어가 목적한 컴퓨터 시스템에서 완벽하게 수행되는가를 점검
- 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트

**인수 테스트**

- 사용자의 요구사항을 충족하는지 중점을 두고 테스트
- 사용자가 직접 테스트

**인수 테스트의 종류**

**사용자 인수 테스트**

- 사용자가 시스템 사용의 적절성 여부를 확인

**운영상의 인수 테스트**

- 시스템 관리자가 인수 시 수행
    - 예) 백업/복원, 재난 복구, 사용자 관리, 정기 점검 등

**계약 인수 테스트**

- 계약상 인수/검수 조건 준수 여부 확인

**규정 인수 테스트**

- 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인

**알파 테스트**

- 개발자 앞에서 사용자가 수행하는 테스트
- 통제된 환경에서 수행되며 오류와 사용상 문제점을 사용자와 개발자가 함께 확인

**베타 테스트**

- 선정된 최종 사용자가 수행하는 테스트

### 통합 테스트

- 단위 테스트가 끝난 모듈을 통합하는 과정을 테스트

**비점진적 통합방식**

- 통합절차 없이 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법 - 빅뱅 통합 테스트

**점진적 통합방식**

- 모듈 단위로 단계적으로 통합하면서 테스트함 - 하향식/상향식/혼합식 통합 테스트

**하향식 통합 테스트 (Top Down Integration Test)**

- 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트

깊이 우선 통합법 또는 넓이 우선 통합법을 사용함

![image](https://github.com/GOBUMGYU/MY_CGV/assets/106207558/243fb301-f84e-4f67-9a4c-962915c922e5)
 
**하향식 통합 테스트 절차**

- 주 제어 모듈은 작성된 프로그램으로 사용하고, 해당 모듈의 종속 모델은 Stub로 대체
    - Stub : 기능을 수행하는 시험용 모듈
- 깊이 우선 또는 넓이 우선 등 방식에 따라 Stub들을 한번에 하나씩 실제 모듈로 교체
- 모듈이 통합될 때마다 테스트 실시
- 새로운 오류가 발생하지 않도록 회귀 테스트 실시

**상향식 통합 테스트 (Bottom Up Integration Test)**

- 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트

**상향식 통합 테스트 절차**

- 하위 모듈들을 클러스터(Cluster)로 결합
    - Cluster : 하나의 주 제어 모듈과 관련된 종속 모듈의 그룹
- 상위 모듈에서 데이터의 입/출력을 확인하기 위해 테스트 드라이버를 작성
- 통합된 클러스터 단위로 테스트
- 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동 결합하고 드라이버는 실제 모듈로 대체

**혼합식 통합 테스트**

- 하위 수준에서는 상향식, 상위 수준에서는 하향식을 사용하여 최적의 테스트를 지원

샌드위치 통합 테스트 방법이라고 함

**회귀 테스팅 (Regression Testing)**

- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트
- 이미 테스트된 프로그램의 테스팅을 반복하는 것

## 애플리케이션 테스트 프로세스

### 테스트 프로세스

개발된 소프트웨어가 사용자의 요구대로 만들어졌는지 테스트하는 절차

**테스트 계획**

- 요구 명세서 등을 기반으로 테스트 목표를 정의하고 테스트 대상 및 범위 결정

**테스트 분석 및 디자인**

- 테스트의 목적과 원칙을 검토하고 사용자 요구사항을 분석

**테스트 케이스 및 시나리오 작성**

- 테스트 케이스를 작성하고 테스트 시나리오를 작성

**테스트 수행**

- 테스트 환경을 구축한 후 테스트 수행

**테스트 결과 평가 및 리포팅**

- 테스트 결과를 비교 분석하여 테스트 결과서 작성

**결함 추적 및 관리**

- 테스트한 후 결함 발생 위치나 종류 등 결함을 추적 관리

**결함 관리 프로세스**

**에러 발견**

- 에러가 발견된 경우 논의를 진행

**에러 등록**

- 발견된 에러를 결함 관리 대장에 등록

**에러 분석**

- 등록된 에러가 실제 결함인지 아닌지 분석

**결함 확정**

- 에러가 실제 결함이면 결함 확정 상태로 설정

**결함 할당**

- 결함 해결 담당자에게 결함을 할당 후 할당 상태로 설정

**결함 조치**

- 결함을 수정하고 수정 완료 시 결함 조치 상태로 설정

**결함 조치 검토 및 승인**

- 수정이 완료된 결함에 대해 확인 테스트를 수행하고, 이상이 없는 경우 결함 조치 완료 상태로 설정

### **테스트 관련 개념**

**테스트 케이스**

- 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서

테스트 케이스를 미리 설계한 경우 테스트 오류 방지, 테스트 수행 인력/시간 등의 자원 낭비를 줄일 수 있음

**테스트 시나리오**

- 테스트 케이스를 적용하는 순서에 따라서 여러 개의 테스트 케이스를 묶은 집합

테스트 케이스를 적용하는 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있음

**테스트 오라클**

- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 정답값을 대입하여 비교하는 활동

**테스트 오라클의 특징**

**제한된 검증**

- 모든 테스트 케이스에 적용할 수는 없음

**수학적 기법**

- 값을 수학적인 기법을 이용하여 구할 수 있음

**자동화 기능**

- 실행, 결과 비교 등을 자동화 할 수 있음

**테스트 오라클의 종류**

**참(True) 오라클**

- 모든 테스트 케이스의 입력값에 대해 기대 결과를 제공하는 오라클
- 발생한 모든 오류 검출 가능

**샘플링오라클**

- 특정 테스트 케이스의 입력값에 대해서만 결과를 제공
- 전수 테스트 불가능 시 사용

**추정 오라클(Heuristic)**

- 특정 테스트 케이스의 입력값에 대해 결과를 제공하고 나머지 값들은 추정으로 처리

**일관성 검사 오라클**

- 애플리케이션에 변경이 있을 경우 테스트 케이스 수행 전과 후의 결과값의 동일성 확인

### 테스트 결함 관리

**결함** : 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것

업무 내용과의 불일치로 인해 변경이 필요한 부분도 결함에 해당

**결함 관리 프로세스**

결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링

→ 최종 결함 분석 및 보고서 작성

**결함 상태 추적 및 결함 관리 측정 지표**

**결함 분포**

- 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정

**결합 추세**

- 테스트 진행 시간에 따른 결함 수의 추이 분석

**결함 에이징**

- 특정 결함 상태로 지속되는 시간 측정

**결함 추적 순서**

**결함 등록(Open)**

- 발견된 결함이 등록된 상태

**결함 검토(Reviewed)**

- 등록된 결함이 검토된 상태

**결함 할당(Assigned)**

- 개발자와 문제 해결 담당자에게 결함이 할당된 상태

**결함 수정(Resolved)**

- 종료 승인한 결함을 검토하여 결함이 아니라고 판명한 상태

**결함의 분류**

**시스템 결함**

- 애플리케이션 환경이나 데이터베이스 처리에서 발생한 결함

**기능 결함**

- 기획, 설계, 업무 시나리오 등의 단계에서 발생한 결함

**GUI 결함**

- 사용자 화면 설계에서 발생한 결함

**문서 결함**

- 기획자, 사용자, 개발자 간 의사소통 및 기록에서 발생한 결함

**결함 심각도**

애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도

**결함 심각도의 분류**

- Critical(치명), Major(주요), Normal(보통), Minor(경미), Simple(단순)

**결함 우선순위**

- 발견된 결함 처리에 신속성을 나타내는 척도

결함의 중요도와 심각도에 따라 설정되어 즉시 해결, 주의 요망, 대기, 개선 권고 등으로 분류

### 애플리케이션 성능 개선

**애플리케이션 성능**

- 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도

**애플리케이션 성능 측정 지표**

**처리량**

- 일정 시간 내에 애플리케이션이 처리하는 일의 양

**응답 시간**

- 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간

**경과 시간**

- 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간

**자원 사용률**

- 의뢰한 작업을 처리하는 동안 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

**성능 테스트 도구**

- 해당 애플리케이션에 부하(Load)나 스트레스를 가하면서 성능 측정 지표를 점검하는 도구

**성능 테스트 도구의 종류**

**JMeter**

- HTTP, FTP등 다양한 프로토콜을 지원하는 테스트 도구

**LoadUI**

- 사용자 편리성이 강화된 테스트 도구로 HTTP, JDBC등 다양한 프로토콜 지원

**OpenSTA**

- HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구, Windows 지원

**시스템 모니터링 도구**

- 애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구

**시스템 모니터링 도구의 종류**

**Scouter**

- 실시간 모니터링, 튜닝에 최적화된 인프라 통합 모니터링 도구

**Zabbix**

- 웹기반 서버, 서비스, 애플리케이션 등의 모니터링 도구

### 복잡도

- 시스템이나 시스템 구성요소의 복잡한 정도

테스트 또는 개발에 사용되는 자원 예측에 사용함

**시간 복잡도**

- 알고리즘을 수행하기 위해 프로세스 수행하는 연산 횟수를 수치화
- 점근 표기법을 사용함

**점근 표기법**

- 하드웨어 성능이나 언어의 종류에 따라 다른 시간 복잡도가 발생하므로 명령어의 실행 횟수를 표기함
- 시간 복잡도가 높을 수록 실행 시간이 길어짐

**점근 표기법의 종류**

**빅오 표기법**

- 알고리즘 실행 시간이 최악인 경우, 명령어의 실행 횟수는 표기 수치보다 많을 수 있음

**세타 표기법**

- 알고리즘 실행 시간이 평균인 경우, 명령어 실행 횟수의 평균적인 수치를 표기

**오메가 표기법**

- 알고리즘 실행시간이 최상인 경우, 명령어의 실행 횟수는 표기 수치보다 적을 수 있음

**빅오 표기법으로 표현한 최악의 알고리즘 시간 복잡도**

**O(1)**

- 입력값에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거치는 경우
    - 예 ) stack의 입/출력 등

**O(log₂n)**

- 문제 해결에 필요한 단계가 입려값(n) 또는 조건에 의해 감소하는 경우
    - 예 ) 이진트리 등

**O(n)**

- 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가지는 경우
    - 예 ) 반복문 등

**O(nlog₂n)**

- 문제 해결에 필요한 단계가 n(log₂n)인 경우
    - 예 ) 힙 정렬 등

**O(n²)**

- 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행되는 경우
    - 예 ) 삽입 정렬 등

**O(2ⁿ)**

- 문제 해결에 필요한 단계가 2의 입력값(n) 제곱만큼 수행되는 경우
    - 예 ) 피보나치 수열 등

**순환 복잡도**

- 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도

맥케이브 순환도 또는 맥케이브 복잡도 매트릭스라고도 함

**순환 복잡도란?**

V(G) = E - N + 2

- G : 제어 흐름도
- V(G) : 순환 복잡도
- E : 화살표의 수
- N : 노드의 수
- 풀이 : V(G) = 화살표 수 - 노드 수 + 2 = 11 - 9 + 2 = 4

### 성능 개선

**소스 코드 최적화**

나쁜 코드를 배제하고 클린 코드로 작성하는 것

**클린 코드**

- 누구나 쉽게 이해하고 수정 및 추가가 가능한 단순, 명료한 코드

**나쁜 코드**

- 프로그램의 논리가 복잡하고 이해하기 어려운 코드
    - 스파게티 코드 : 코드의 로직이 서로 복잡하고 얽혀 있는 코드
    - 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

**클린 코드 작성 원칙**

**가독성** - 누군든지 코드를 쉽게 읽을 수 있도록 작성함(쉬운 용어 또는 들여쓰기 기능 사용)

**단순성** - 코드를 간단하게 작성함

**의존성 배제** - 코드가 다른 모듈에 미치는 영향을 최소화하여 코드 변경 시 다른 부분에 영향이 없도록 작성함

**중복성 최소화** - 코드의 중복을 최소화함

**추상화** - 상위 클래스에서 간략한 특성을 나타내고 하위 클래스에서 상세 내용을 구현함

**소스 코드 최적화 유형**

**클래스 분할 배치**

- 하나의 클래스는 하나의 역활만 수행하도록 응집도를 높이고 크기를 작게 작성함

**느슨한 결합**

- 인터페이스 클래스를 이용하여 클래스 간의 의존성을 최소화함

**소스 코드 품질 분석 도구**

**정적 분석 도구**

코드를 실행하지 않고 코딩 표준이나 코딩 스타일 결함 등을 확인하는 분석 도구

- pmd : 소스 코드에 대한 미사용 변수, 최적화 되지 않은 코드 등을 검사
- cppcheck : c/c++코드에 대한 메모리 누수, 오버플로우 등 분석
- SonarQube : 중복 코드, 복잡도 등을 분석
- checkStyle : Java코드에 대해 코드 표준을 따르는지 검사
- ccm : 다양한 언어 코드 복잡도 분석
- coberture : java의 소스 코드 복잡도 분석 및 테스트 커버리지 측정

**동적 분석 도구**

코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 분석 도구

- Avalanche : 프로그램에 대한 결함 및 취약점 등을 분석
- Valgrid : 프로그램 내에 존재하는 메모리 및 쓰레드 결함 등을 분석