# 시간복잡도 공간복잡도

시간 복잡도란 ? **특정 작업을 하는데 얼마만큼 시간이 걸리느냐** or **알고리즘을 수행하는 데 연산들이 몇번 이루어지는지를 숫자로 표현** 즉, **절대적인 시간을 나타내는 것은 아니다.**

**빅오 표기법에서는 모든 상수값을 무시한다.**

```groovy
public class Main {
    public static void main(String[] args) {
        // 2단~9단까지의 구구단
        for (int i = 2; i <= 9; i++) {
            System.out.println("==============" + i + "단==============");
            for (int j = 1; j <= 9; j++) {
                System.out.println(i + " X " + j + " = " + (i * j));
            }
        }
    }
}
```

시간 복잡도를 계산할 때, **작업량은 ‘한 사이클’이 기준**이다.

한 싸이클이란 한 번의 계산으로 끝나는 것이 아니라, 반복문 등 여러번의 작업이 요구되는 기준

예를 들어 System.out.println(i + " X " + j + " = " + (i * j)); 의 경우 단순 및 계산 출력으로 한번의 계산으로 끝나게 된다. 그런데 반복문 같은 경우는 한 번이 아니라 여러 번에 걸쳐 작업을 하게 된다.

즉, **시간 복잡도에서 중요한 것은 바로 이 싸이클**

위 구구단 예제의 총 작업 횟수를 세어보자! 총 작업량은 첫 번째 반복문에서 i에 2~9까지 대입하여 총 8회, 두 번째 반복문에서 j에 1~9까지 대입하여 총 9회, 즉 8 * 9 = 72로 가정

이 반복 되는 숫자들은 n으로 치환 8 * 9 = 72 ⇒ n * n = n²이다

즉, 이 구구단은 O(n²)의 시간 복잡도를 가진 알고리즘이다

다음 예시를 보겠다

```groovy
public class Main {
    public static void main(String[] args) {
        // 2단~9단까지의 구구단
        for (int i = 2; i <= 9; i++) {
            System.out.println("==============" + i + "단==============");
            for (int j = 1; j <= 9; j++) {
                System.out.println(i + " X " + j + " = " + (i * j));
            }

            for (int j = 10; j <= 19; j++) {
                System.out.println(i + " X " + j + " = " + (i * j));
            }
        }
    }
}
```

구구단을 단순히 * 9 까지만 하는 것이 아니라, * 19까지 계산하는 로직으로 추가되었다.

그럼 이 코드의 시간 복잡도는 얼마일까?

의아하게도 이전과 마찬가지로 n²이다

x² * 2x * 3 이 있을 때, 빅오 표기법은 x²만 표시된다.

위 구구단을 수식으로 나타내자면, n² * (n+n) ⇒ n² * 2n 즉 최고차항인 n²만 살아남는다.

**빅오 표기법에서는 무조건 최고차항만 보면된다.**

## 시간 복잡도 (Worst Case)로 보통 계산

빅오 표기법과 도출 방법은 이 정도로 마치고, 시간 복잡도에서 알아보자

시간 복잡도는 빅오 표기법에서 도출되는 값이라고 보면 된다.

그리고 알아야 할 사항으로, 일반적으로 알고리즘 테스트를 볼 때 총 작업량이 1억(100,000,000)번을 넘으면 시간 복잡도 면에서 탈락한다. 예를 들면 n = 100,000이라고 가정한다면, n²으로 풀면 시간 복잡도를 통과하지 못한다는 것이다.

시간 복잡도에서 흔히 갖게 되는 값과 그 크기를 비교해보자

O(N!) > O(2ⁿ) > O(N²) > O(N log N) > O(N) > O(Log N) >  O(1)

팩토리얼 > 재귀함수 > 중첩반복문 > 퀵정렬,  병합정렬 > 반복문 > 이진탐색 > 상수

첫번째로 O(N!)에서 ‘!’는 팩토리얼을 의미하며, 예를 들어 !5 = 5 * 4 * 3 * 2 * 1과 같은 값을 갖게 되는 것이 팩토리얼이다.

두번째 O(2^n) 에서 ^특수문자 뒤에 오는 숫자는 제곱되는 값을 말한다. 즉 O(2^2) = O(2²) 이다.

세번째 O(Log N)은 한번 실행할 때마다 숫자가 절반으로 줄어드는 것을 의미

```groovy
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int find = 2;
        int count = 1;
        int i = 0;
        int l = 0;
        int r = arr.length - 1;

        // 배열에서 1~10까지의 수 중, 변수 find에 들어가 있는 값 2를 찾는 알고리즘
        while (true) {
            i = (l + r) / 2;
            if (find == arr[i]) {
                System.out.println(count + "번만에 찾았습니다.");
                break;
            }

            if (l > r) {
                System.out.println(count + "번을 탐색해도 해당 값을 찾지 못했습니다.");
                break;
            }

            if (find > arr[i]) {
                l = i + 1;
            } else {
                r = i - 1;
            }
            count++;
        }
    }
}
```

위 코드는 이진 탐색으로 사용되는 방법인데, 대충 설명하자면 1부터 10까지 저장된 배열이 있고, 2라는 값을 찾고 싶은 경우에 다음과 같이 탐색한다.

1. 찾는 값과 배열 중간에 있는 값을 비교한다.
2. 두 값이 다른 경우, 찾는 값이 중간 값보다 작은 경우에는 중간값 기준 배열의 왼쪽을 확인하고 큰 경우에는 배열의 오른쪽을 확인한다.
3. 이를 값을 찾을 때까지 반복한다.

작성한 코드로 보면

1. 찾는 값 = 2 ,중간 값 = 6
2. 2는 6보다 작으므로, 1~5까지의 배열 중에서 가운데에 있는 값을 다시 확인
3. 찾는 값 = 2, 중간 값 = 3
4. 2는 3보다 작으므로, 1~2까지의 배열 중에서 가운데에 있는 값을 확인
5. 찾는 값 = 2, 중간 값 = 2
6. 찾는 값과 중간 값이 같으므로, 몇번의 작업이 걸렸는지 반환

위 방법대로 짜여진 코드인데, 코드를 당장 이해하는 것 보다 중요한 점은 한 번 작업할 때마다 확인할 것이 절반씩 줄었다이다.

원래 1~10까지 담긴 배열 전체를 조회하려면 10번을 해야 하는데, 3번의 작업만으로 값을 찾을 수 있었고 이와 같이 한번 작업할 때마다 확인할 경우의 수가 절반씩 줄어드는 알고리즘을 O(Log N)의 시간 복잡도를 갖고 있다고 한다.

다시 본론으로 돌아와서, 프로그래머는 가능한 적은 시간복잡도를 가질수 있도록 알고리즘을 구현해야 하며 조금 난이도가 있는 문제에서는 이 시간 복잡도를 최소로 갖는 알고리즘을 구현하는 문제를 내고 있으니 어떤 알고리즘을 보면 시간 복잡도를 계산하는 습관을 들여야 한다.

### 알고리즘 성능 분석의 필요성

프로그램의 규모는 시간이 지날수록 방대해지고 있다. 즉, 처리해야하는 데이터의 양이 많아진다는 것을 의미

입력하는 데이터의 양이 적은 경우에는 무시해도 크게 상관이 없을 수 있지만, 그 양이 많아지면 알고리즘 간의 효율성 차이는 커질 수 밖에 없다.

예를 들어보자.

| 입력 데이터의 개수 | 알고리즘A O(n²) | 알고리즘B O(2ⁿ) |
| --- | --- | --- |
| n = 6 | 36초 | 64초 |
| n = 100 | 10,000초 | 2¹⁰⁰초 = 4 * 10²²년 |

위 표에서 알 수 있듯이 입력한 데이터 개수가 6개 미만일 경우에는 알고리즘 A와 B의 실행 속도 차이가 2배를 넘지 않지만, 입력 개수가 100이라고 가정한다면 실행 속도의 차이는 엄청나게 커진다.

효율적인 알고리즘이란?

알고리즘이 수행을 시작하여 결과를 도출할 때 까지 실행에 걸리는 시간이 짧고 연산하는 컴퓨터 내의 메모리와 같은 자원을 덜 사용하는 것 효율적이라고 할 수 있다.

n에 연산이란 종류로 산술, 대입, 비교, 이동을 말함 그런데 Operation의 실행 횟수는 보편적으로 그 값이 변하지 않는 상수가 아니라 입력한 데이터의 개수를 나타내는 n의 함수로 나타낸 것을 시간 복잡도라고 말하며 수식으로는 T(n)이라고 표기한다.

### 알고리즘의 성능 분석

**시간효율성**

- 알고리즘의 실행 시간
- 전체 실행 시간이 짧은 알고리즘이 더 좋음

**공간효율성**

- 알고리즘이 사용하는 메모리 양
- 컴퓨터 메모리를 더 적게 사용하는 알고리즘이 더 좋음

### 실행 시간 측정 방법의 문제점

**반드시 구현해야 함**

- 이론적 분석 방법은 구현하지 않아도 분석가능 측정은 못함

**같은 조건에서 실행해야 함**

- 동일한 하드웨어, 프로그래밍 언어, 운영체제 등

**동일한 테스트 데이터를 사용해야 함**

- 알고리즘에 유리한 데이터, 불리한 데이터가 있음

